#BlueJ class context
comment0.target=ArrayExperimente
comment0.text=\r\n\ Uebungen\ mit\ Arrays.\ \r\n\ \r\n\ Die\ Lerngrupe\ erstellt\ Funktionen,\ die\ sehr\ einfache\ Operationen\ \r\n\ auf\ int-Arrays\ durchfuehren.\r\n\ \r\n\ @author\ Urs\ Lautebach\r\n\ @version\ 30.10.2015\r\n
comment1.params=auszugebendesArray
comment1.target=void\ arrayAusgeben(int[])
comment1.text=\r\n\ Gibt\ das\ uebergebene\ Array\ auf\ der\ Konsole\ aus.\r\n\ @param\ Array,\ das\ ausgegeben\ werden\ soll.\r\n
comment10.params=a\ b
comment10.target=int[]\ vektorsumme(int[],\ int[])
comment10.text=\r\n\ Berechnet\ die\ Vektorsumme\ der\ Arrays\ a\ und\ b\r\n\ (elementweise\ Summe).\r\n\ a\ und\ b\ MUESSEN\ gleiche\ Laenge\ haben\ -\ die\ Funktion\r\n\ gibt\ sonst\ null\ zurueck\!\r\n\ @param\ a\ ein\ Vektor,\ darf\ nicht\ null\ sein\r\n\ @param\ b\ noch\ ein\ Vektor,\ darf\ nicht\ null\ sein\r\n\ @returns\ Summe\ von\ a\ und\ b\r\n
comment11.params=wendeArray
comment11.target=int[]\ arrayUmdrehen(int[])
comment11.text=\r\n\ Erstellt\ ein\ neues\ Array,\ in\ dem\ die\ Elemente\ des\r\n\ urspruenglichen\ Array\ in\ der\ umgekehrten\ Reihenfolge\ drin\ sind.\r\n\ @param\ array\ urspruengliches\ Array,\ darf\ nicht\ null\ sein\r\n\ @returns\ neues\ Array\ mit\ umgekehrter\ Reihenfolge.\r\n
comment12.params=wendeArray
comment12.target=void\ arrayUmdrehenInPlace(int[])
comment12.text=\r\n\ Dreht\ im\ bestehenden\ Array\ dessen\ Elemente\ in\ \r\n\ die\ umgekehrte\ Reihenfolge.\ Man\ sagt,\ die\ Funktion\ bearbeitet\ \r\n\ das\ Array\ "in\ place".\r\n\ @param\ wendeArray\ urspruengliches\ Array\ \r\n
comment13.params=bits
comment13.target=long\ binaerNachDezimal(boolean[])
comment13.text=\r\n\ Wandelt\ ein\ Array\ von\ Booleans\ in\ einen\ long-Wert\ um.\r\n\ \r\n\ @param\ bits\ Array,\ das\ als\ Binaerwort\ interpretiert\ wird.\ \r\n\ Die\ Eintraege\ links\ (bei\ kleinen\ Indizes)\ sollen\ als\ \r\n\ hoeherwertige,\ die\ rechts\ (bei\ grossen\ Indizes)\ als\ \r\n\ niederwertigere\ Binaerstellen\ interpretiert\ werden.\ \r\n\ Das\ Array\ soll\ maximal\ 63\ Eintraege\ haben,\ damit\ zunaechst\r\n\ nicht\ ueber\ Zweierkomplemente\ nachgedacht\ werden\ muss.\r\n\ \r\n\ @returns\ die\ resultierende\ Zahl;\ -1,\ falls\ das\ uebergebene\ Array\r\n\ nicht\ in\ einen\ long\ umgewandelt\ werden\ kann.\r\n
comment14.params=zahl
comment14.target=boolean[]\ dezimalNachBinaer(short)
comment14.text=\r\n\ Wandelt\ einen\ short-Wert\ in\ ein\ Array\ von\ Booleans\ um.\r\n\ \r\n\ @returns\ Array,\ das\ als\ Binaerwort\ interpretiert\ wird.\ \r\n\ Jedes\ boolean\ darin\ steht\ fuer\ ein\ Bit.\ \r\n\ Die\ Eintraege\ links\ (bei\ kleinen\ Indizes)\ sollen\ als\ \r\n\ hoeherwertige,\ die\ rechts\ (bei\ grossen\ Indizes)\ als\ \r\n\ niederwertigere\ Binaerstellen\ interpretiert\ werden.\ \r\n\ Der\ Rueckgabewert\ ist\ null,\ falls\ zahl\ negativ\ ist.\r\n\ \r\n\ @param\ zahl\ die\ Zahl,\ die\ umgewandelt\ werden\ soll.\r\n
comment15.params=array
comment15.target=void\ bubbleSort(int[])
comment15.text=\r\n\ Die\ Funktion\ sortiert\ das\ uebergebene\ Array\ aufsteigend\ und\ in-place.\r\n\ @param\ array\ Das\ zu\ sortierende\ Array.\r\n
comment2.params=
comment2.target=void\ testen()
comment3.params=gesucht\ durchsuchArray
comment3.target=boolean\ istEnthalten(int,\ int[])
comment3.text=\r\n\ Ermittelt,\ ob\ der\ Wert\ von\ x\ im\ Array\ vorkommt,\ d.h.\ ob\r\n\ eines\ der\ Arrayelemente\ den\ Wert\ x\ hat.\r\n\ @param\ x\ zu\ suchender\ Wert.\r\n\ @param\ dasArray\ Array,\ in\ dem\ gesucht\ wird.\r\n\ @returns\ ob\ x\ im\ Array\ vorkommt.\r\n
comment4.params=gesucht\ durchsuchArray
comment4.target=int\ indexVon(int,\ int[])
comment4.text=\r\n\ Ermittelt,\ an\ welchem\ Index\ im\ Array\ der\ Wert\ "gesucht"\ vorkommt.\r\n\ @param\ gesucht\ Wert,\ nach\ dem\ im\ Array\ gesucht\ wird.\r\n\ @param\ durchsuchArray\ Array,\ in\ dem\ gesucht\ wird.\r\n\ @returns\ den\ Index,\ an\ dem\ gesucht\ im\ Array\ vorkommt;\ -1,\ falls\ es\r\n\ nicht\ vorkommt.\r\n
comment5.params=durchsuchArray
comment5.target=int\ maxWert(int[])
comment5.text=\r\n\ Ermittelt\ den\ Wert\ des\ groessten\ im\ Array\ enthaltenen\ Elements.\r\n\ @param\ dasArray\ Array,\ in\ dem\ gesucht\ wird.\ Es\ darf\ nicht\ leer\ sein.\r\n\ @returns\ Den\ groessten\ vorkommenden\ Wert.\r\n
comment6.params=durchsuchArray
comment6.target=int\ maxIndex(int[])
comment6.text=\r\n\ Ermittelt\ den\ Index\ des\ groessten\ im\ Array\ enthaltenen\ Elements.\r\n\ @param\ dasArray\ Array,\ in\ dem\ gesucht\ wird.\r\n\ @returns\ Den\ Index\ des\ groessten\ vorkommenden\ Werts.\r\n
comment7.params=durchsuchArray
comment7.target=int\ maxIndex_Eleganter(int[])
comment7.text=\r\n\ Ermittelt\ den\ Index\ des\ groessten\ im\ Array\ enthaltenen\ Elements.\ \r\n\ @param\ dasArray\ Array,\ in\ dem\ gesucht\ wird.\r\n\ @returns\ Den\ Index\ des\ groessten\ vorkommenden\ Werts.\r\n
comment8.params=aufaddierArray
comment8.target=int\ querSumme(int[])
comment8.text=\r\n\ Ermittelt\ die\ Summe\ ueber\ alle\ Arrayelemente.\r\n\ @param\ dasArray\ Array,\ das\ aufaddiert\ wird.\r\n\ @returns\ Summe\ aller\ Arrayelemente.\r\n
comment9.params=bspArray\ zuschlag
comment9.target=void\ addiereJeweilsD(int[],\ int)
comment9.text=\r\n\ Die\ Funktion\ erhoeht\ im\ urspruenglichen\ Array\ jeden\ Eintrag\ um\ "zuschlag".\r\n\ Es\ wird\ kein\ neues\ Array\ angelegt.\r\n\ @param\ dasArray\ Zu\ manipulierendes\ Array.\ Es\ darf\ nicht\ leer\ sein.\ \ \ \ \r\n\ @param\ zuschlag\ diese\ Zahl\ wird\ zu\ jedem\ Arrayeintrag\ dazuaddiert.\r\n
numComments=16
